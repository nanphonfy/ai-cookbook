>这一讲首先介绍了一个移动方块的人工智能程序，并以此详细讲解了目标树的概念，这一程序不仅能够能够实现目标，还能解释自己在过程中的一些行为;
第二部分，教授详细介绍了基于规则的专家系统，有一个医疗方面的专家系统比医生的诊断还要准确，教授讲解了它是如何做到的;    
第三部分，教授通过杂货店装袋的例子，总结了知识工程中的三大原则。

>学会如何写出这样的程序，知道回答关于自身行为的问题。
包含模块、子程序，  
有一些方块，怎么放到较大的上面？  

>put on，四个步骤:
>>①为它找到空间；  
②拿较小的（上面不能有东西，需调用，清空顶部，可能循环多次）（上面不能有东西，需调用，清空顶部，可能循环多次），然后递归到put on；  
③移动；  
④放手；  

>递归会让程序在解决问题时的行为复杂性提高很多。程序结构非常简单，怎么做到看似复杂的系统？
>>简单的方块问题模拟：

方块 | 方块
---|---
BX | BY
B1 | B2

>把B1放到B2，导致4个子程序运行：找空间->抓住B1（清空底部->移动BX->释放BX到桌面）->移动->释放。  
>>用到这棵树的踪迹：  
回答为什么要挪开BX？它会往上一层，然后汇报结果。  
我移开了BX》为了清空B1顶部;  
为什么要清空B1顶部？因为我要抓起它；  
为什么要抓起它？因为我要把B1放到B2上；  
为什么要把B1放到B2上？因为你要我这么做。  

>即应对“为什么”这类问题的方式。 

>“如何”的问题？它会往下一层。  
>>从最上面的put on开始。哦，我做了四件事；  
你如何抓起B1?我将它顶部清空；  
如何将它顶部清空？我移开BX;  
如何移开BX?把它放到桌上。  

>即应对“如何”这类问题的方式。
沿这棵树往下追踪程序动作，看到它们如何组织在一起。
留下踪迹的树，即目标树（eg.同积分之间的关系）。  
只要建立与/或树，就能回答关于自身行为的问题，也意味着程序积分也能回答关于其行为的问题。
在求解问题的过程中建立了一棵目标树。

>行为的复杂性在很大程度上，不是程序的复杂性，而是问题的复杂性。  
需建立一棵巨大的目标树，引出核心要义：该理念可追溯到六十年代晚期， 赫伯特.西蒙说：可想象海滩上蚂蚁爬行轨迹，轨迹看似很复杂，但实际上沙滩上有一些小砂砾，蚂蚁只是为了避开它们改变轨迹。  
由此可见，行为复杂性来自环境复杂性，而不是程序复杂性。  
行为复杂性=max(程序复杂性,环境复杂性)

>以目标为中心的编程转到基于规则的专家系统。背景：80年代中期，人们热衷将人工智能用于商业。  
当时学术界认为人类智能中所有有用的方面，都可以用简单规则形式的知识表示出来。
经典例子：Mycin->医生想知道应用什么抗生素治病，它会问很多问题。  
以小动物园类比：有毛发、有爪、牙尖、向前的眼睛、吃肉、有斑点，跑很快->猎豹
若有毛发->规则1,必然是一种哺乳动物；   
若尖爪、尖牙、眼睛向前->规则2，必然是食肉动物；  
吃肉->规则2；  
哺乳动物、食肉动物、有斑点且跑的快->猎豹。 

>基于规则的专家系统，向前链系统（从已知事实往前推结论），因为它要使用规则（只是使用了条件反射规则）
基于规则的新手系统。  
该系统也能回答关于自身行为的问题，因为它也是一棵目标树。  
规则可以用与/或节点表示，留下目标树的踪迹。  
为什么你对动物爪感兴趣？尝试确认它是一种食肉动物；  
怎么知道动物是一种哺乳动物？因为它有头发；  
为什么认为是猎豹？因为它是哺乳、食肉动物、有斑点、跑得快。  

>从一个假设回溯，叫做后向链基于规则的专家系统。

>某建筑系博士生的毕业论文，就是基于建筑师西萨的作品，能设计出和西萨设计类似的房子。  
亮点：将程序的一些设计成果，同西萨本人作品混在一起，让西萨选择哪些是他设计的，他本人都分辨不出来。

